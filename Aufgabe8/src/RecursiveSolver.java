package src;

import src.data.*;
import src.utils.Direction;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The class constructs and evaluates cube structures using recursion.
 * <p>
 * The RecursiveSolver implements an algorithm to find optimal arrangements of cubes
 * within a structure based on a recursive approach. It uses the evaluators and validators provided to it as parameters.
 * </p>
 */
public class RecursiveSolver {
    int n, k; // Number of cubes to place and maximum solutions to retain
    SolutionEvaluator evaluator; // Evaluator to score structures
    PlacementValidator validator; // Validator to check placement constraints
    private final AtomicInteger structureCounter;

    /**
     * Constructs a RecursiveSolver with the specified parameters.
     *
     * @param n          the number of cubes to place
     * @param k          the maximum number of solutions to retain
     * @param validator  a PlacementValidator to ensure valid cube placements
     * @param evaluator  a SolutionEvaluator to score cube structures
     */
    public RecursiveSolver(int n, int k, SolutionEvaluator evaluator, PlacementValidator validator, AtomicInteger structureCounter) {
        this.n = n;
        this.k = k;
        this.evaluator = evaluator;
        this.validator = validator;
        this.structureCounter = structureCounter;
    }

    /**
     * Initiates the recursive solving process to find optimal cube arrangements.
     * <p>
     * The solving process starts with an empty structure and iteratively adds cubes
     * based on the recursive logic.
     * </p>
     *
     * @return a list of optimal solutions
     */
    public List<Structure> solve() {
        return solveRecursive(List.of(new Structure(new HashSet<>(), 0)), n);
    }

    /**
     * Recursively generates solutions by adding cubes to existing structures.
     * <p>
     * At each recursive step, new solutions are generated by adding cubes to the
     * current solutions. A weighted random selection process ensures diversity among
     * the retained solutions.
     * </p>
     *
     * @param currentSolutions the list of current solutions
     * @param n                the remaining number of cubes to place
     * @return a list of refined solutions after the recursive step
     */
    private List<Structure> solveRecursive(List<Structure> currentSolutions, int n) {
        if (n == 0 || currentSolutions == null) {
            return currentSolutions;
        }
        List<Structure> newSolutions = generateNewSolutions(currentSolutions).collect(Collectors.toList());
        structureCounter.addAndGet(newSolutions.size());
        Comparator<Structure> scoreComparator = Comparator.comparingDouble(Structure::getScore);
        Structure bestSolution = newSolutions.stream().max(scoreComparator).orElse(null);

        List<Structure> selectedSolutions = new ArrayList<>(List.of(bestSolution));
        newSolutions.remove(bestSolution);

        // The weighted random selection doesn't seem to be suited for a functional approach, as we need to
        // somehow artificially generate a new collection with new random weighted scores to avoid violating
        // the inherent contract of the comparator / sorted list (at least this is the exception I am receiving).
        // Thus -> implemented procedurally.
        Random random = new Random();
        double totalScore = newSolutions.stream().mapToDouble(Structure::getScore).sum();

        while (selectedSolutions.size() < k && newSolutions.size() > 1) {
            double target = random.nextDouble() * totalScore;
            double cumulativeScore = 0.0;
            Iterator<Structure> iterator = newSolutions.iterator();
            while (iterator.hasNext()) {
                Structure solution = iterator.next();
                cumulativeScore += solution.getScore();
                if (cumulativeScore >= target) {
                    selectedSolutions.add(solution);
                    totalScore -= solution.getScore();
                    iterator.remove();
                    break;
                }
            }
        }
        return solveRecursive(selectedSolutions, n - 1);
    }

    /**
     * Generates new solutions by adding valid cubes to the current structures using parallel streams.
     *
     * @param currentSolutions the current list of structures
     * @return a Stream of newly generated structures
     */
    private Stream<Structure> generateNewSolutions(List<Structure> currentSolutions) {
        // parallelization of this stream results in a considerable performance benefit
        return currentSolutions.parallelStream()
                .flatMap(structure -> generatePossibleCubes(structure)
                        .filter(cube -> validator.isValid(structure, cube))
                        .map(cube -> {
                            Structure newStructure = structure.addCube(cube);
                            double newScore = evaluator.evaluate(newStructure);
                            return new Structure(newStructure.getCubes(), newScore);
                        }))
                .distinct();
    }

    /**
     * Generates possible cube placements for the next recursive step.
     * <p>
     * Possible cubes are determined based on the current structure and the directions
     * in which cubes can be added. A shuffled order of directions ensures randomness.
     * </p>
     *
     * @param structure the current structure
     * @return a Stream of candidate cubes for placement
     */
    private Stream<Cube> generatePossibleCubes(Structure structure) {
        if (structure.isEmpty()) {
            return Stream.of(new Cube(0, 0, 0));
        }

        return structure.stream()
                .flatMap(cube -> Direction.randomDirStream() // shuffle to maintain randomness
                        .filter(dir -> dir != Direction.DOWN)
                        .map(dir -> new Cube(cube.x() + dir.dx, cube.y() + dir.dy, cube.z() + dir.dz)))
                .filter(cube -> !structure.contains(cube))
                .distinct();
    }
}


